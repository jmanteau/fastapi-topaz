"""
Policy generation and validation utilities.

Generate Rego policy skeletons from FastAPI routes and validate policies at startup.
"""
from __future__ import annotations

import re
from dataclasses import dataclass, field
from pathlib import Path
from typing import TYPE_CHECKING, Any, cast

if TYPE_CHECKING:
    from fastapi import FastAPI
    from fastapi.routing import APIRoute

    from .dependencies import TopazConfig

__all__ = [
    "generate_policies",
    "policy_diff",
    "PolicyTemplate",
    "PolicyDiff",
    "MissingPolicy",
    "ValidationResult",
]


@dataclass
class PolicyTemplate:
    """Configuration for generated Rego policies."""

    default_decision: bool = False
    include_comments: bool = True
    include_route_info: bool = True
    include_input_schema: bool = True
    include_ds_check: bool = True  # For ReBAC


@dataclass
class MissingPolicy:
    """Information about a missing policy."""

    policy_path: str
    method: str
    path: str
    route_pattern: str
    auth_type: str  # "policy" or "rebac"


@dataclass
class PolicyDiff:
    """Result of comparing routes against policies."""

    missing: list[MissingPolicy] = field(default_factory=list)
    orphaned: list[str] = field(default_factory=list)
    valid: list[str] = field(default_factory=list)

    @property
    def has_issues(self) -> bool:
        return len(self.missing) > 0 or len(self.orphaned) > 0


@dataclass
class ValidationResult:
    """Result of policy validation."""

    valid: bool
    total_routes: int
    total_policies: int
    missing_policies: list[MissingPolicy] = field(default_factory=list)
    orphaned_policies: list[str] = field(default_factory=list)
    validated_policies: list[str] = field(default_factory=list)


def _policy_path_heuristic(path: str) -> str:
    """Convert URL path to policy path segment."""
    if not path or path == "/":
        return ""
    segments = path.strip("/").split("/")
    result_parts: list[str] = []
    for segment in segments:
        if not segment:
            continue
        if segment.startswith("{") and segment.endswith("}"):
            param_name = segment[1:-1]
            result_parts.append(f"__{param_name}")
        else:
            result_parts.append(segment)
    if not result_parts:
        return ""
    return "." + ".".join(result_parts)


def _resolve_policy_path(root: str, method: str, path: str) -> str:
    """Build full policy path from root, method, and URL path."""
    heuristic = _policy_path_heuristic(path)
    return f"{root}.{method}{heuristic}"


def _extract_path_params(path: str) -> list[str]:
    """Extract path parameter names from a route path."""
    return re.findall(r"\{(\w+)\}", path)


def _generate_policy_rego(
    policy_path: str,
    route_path: str,
    method: str,
    template: PolicyTemplate,
    is_rebac: bool = False,
) -> str:
    """Generate Rego policy content."""
    lines = [f"package {policy_path}", "", "import rego.v1", ""]

    default_val = "true" if template.default_decision else "false"
    lines.append(f"default allowed = {default_val}")
    lines.append("")

    if template.include_comments and template.include_route_info:
        lines.append(f"# Route: {method} {route_path}")
        params = _extract_path_params(route_path)
        if params:
            lines.append(f"# Path params: {', '.join(params)}")
        lines.append(f"# Auth type: {'rebac' if is_rebac else 'policy'}")
        lines.append("# Generated by fastapi-topaz")
        lines.append("#")

    if template.include_comments and template.include_input_schema:
        lines.append("# Available input:")
        lines.append('#   - input.identity.type: Identity type (e.g., "IDENTITY_TYPE_SUB")')
        lines.append("#   - input.identity.value: User ID")
        if is_rebac:
            lines.append('#   - input.resource.object_type: Resource type (e.g., "document")')
            lines.append("#   - input.resource.object_id: Resource ID")
            lines.append('#   - input.resource.relation: Relation to check (e.g., "can_write")')
            lines.append('#   - input.resource.subject_type: Subject type (default: "user")')
        else:
            for param in _extract_path_params(route_path):
                lines.append(f"#   - input.resource.{param}: Value of {{{param}}} path parameter")
        lines.append("")

    if is_rebac and template.include_ds_check:
        lines.extend([
            "allowed if {",
            "    ds.check({",
            '        "object_type": input.resource.object_type,',
            '        "object_id": input.resource.object_id,',
            '        "relation": input.resource.relation,',
            '        "subject_type": input.resource.subject_type,',
            '        "subject_id": input.identity.value,',
            "    })",
            "}",
        ])
    else:
        lines.extend([
            "allowed if {",
            "    # TODO: Implement authorization logic",
            '    input.identity.type == "IDENTITY_TYPE_SUB"',
            "}",
        ])

    return "\n".join(lines) + "\n"


DEFAULT_EXCLUDE_PATHS = {
    "/openapi.json",
    "/docs",
    "/docs/oauth2-redirect",
    "/redoc",
}


def scan_routes(
    app: FastAPI,
    policy_root: str,
    exclude_paths: set[str] | None = None,
) -> list[dict[str, Any]]:
    """
    Scan FastAPI app routes and extract policy information.

    Args:
        app: FastAPI application instance
        policy_root: Policy path root
        exclude_paths: Paths to exclude (defaults to docs routes)

    Returns list of route info dicts with policy_path, method, path, etc.
    """
    if exclude_paths is None:
        exclude_paths = DEFAULT_EXCLUDE_PATHS

    routes = []
    for route in app.routes:
        if not hasattr(route, "methods") or not hasattr(route, "path"):
            continue

        api_route = cast("APIRoute", route)
        path = api_route.path
        if path in exclude_paths:
            continue

        for method in api_route.methods or []:
            if method in ("HEAD", "OPTIONS"):
                continue

            policy_path = _resolve_policy_path(policy_root, method, path)
            routes.append({
                "policy_path": policy_path,
                "method": method,
                "path": path,
                "route_pattern": path,
                "auth_type": "policy",  # Default, could be detected from dependencies
            })

    return routes


def generate_policies(
    app: FastAPI,
    config: TopazConfig,
    output_dir: str | Path | None = None,
    template: PolicyTemplate | None = None,
) -> dict[str, str]:
    """
    Generate Rego policy skeletons from FastAPI routes.

    Args:
        app: FastAPI application instance
        config: TopazConfig with policy_path_root
        output_dir: Optional directory to write policy files
        template: Optional template configuration

    Returns:
        Dict mapping policy paths to Rego content
    """
    template = template or PolicyTemplate()
    routes = scan_routes(app, config.policy_path_root)
    policies: dict[str, str] = {}

    for route_info in routes:
        policy_path = route_info["policy_path"]
        rego = _generate_policy_rego(
            policy_path,
            route_info["path"],
            route_info["method"],
            template,
            is_rebac=route_info["auth_type"] == "rebac",
        )
        policies[policy_path] = rego

    # Generate ReBAC check policy
    rebac_path = f"{config.policy_path_root}.check"
    policies[rebac_path] = _generate_policy_rego(
        rebac_path, "/check", "CHECK", template, is_rebac=True
    )

    if output_dir:
        output_path = Path(output_dir)
        output_path.mkdir(parents=True, exist_ok=True)
        for policy_path, content in policies.items():
            file_path = output_path / f"{policy_path.replace('.', '/')}.rego"
            file_path.parent.mkdir(parents=True, exist_ok=True)
            file_path.write_text(content)

    return policies


def policy_diff(
    app: FastAPI,
    config: TopazConfig,
    policies_dir: str | Path,
) -> PolicyDiff:
    """
    Compare FastAPI routes against existing policy files.

    Args:
        app: FastAPI application instance
        config: TopazConfig with policy_path_root
        policies_dir: Directory containing .rego policy files

    Returns:
        PolicyDiff with missing, orphaned, and valid policies
    """
    policies_path = Path(policies_dir)
    routes = scan_routes(app, config.policy_path_root)
    route_policies = {r["policy_path"] for r in routes}
    route_policies.add(f"{config.policy_path_root}.check")  # ReBAC policy

    # Find existing policies
    existing_policies: set[str] = set()
    if policies_path.exists():
        for rego_file in policies_path.rglob("*.rego"):
            relative = rego_file.relative_to(policies_path)
            policy_path = str(relative.with_suffix("")).replace("/", ".")
            existing_policies.add(policy_path)

    diff = PolicyDiff()

    # Find missing policies
    for route_info in routes:
        policy_path = route_info["policy_path"]
        if policy_path not in existing_policies:
            diff.missing.append(
                MissingPolicy(
                    policy_path=policy_path,
                    method=route_info["method"],
                    path=route_info["path"],
                    route_pattern=route_info["route_pattern"],
                    auth_type=route_info["auth_type"],
                )
            )
        else:
            diff.valid.append(policy_path)

    # Check ReBAC policy
    rebac_path = f"{config.policy_path_root}.check"
    if rebac_path not in existing_policies:
        diff.missing.append(
            MissingPolicy(
                policy_path=rebac_path,
                method="CHECK",
                path="/check",
                route_pattern="/check",
                auth_type="rebac",
            )
        )
    else:
        diff.valid.append(rebac_path)

    # Find orphaned policies
    for policy in existing_policies:
        if policy not in route_policies:
            diff.orphaned.append(policy)

    return diff
